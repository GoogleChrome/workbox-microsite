---
layout: jsdoc
title: "Source: packages/workbox-webpack-plugin/index.js"
jsdocNav: 
  - Modules:
    - <a href="module-workbox-background-sync.html#main">workbox-background-sync</a>
    - <a href="module-workbox-broadcast-cache-update.html#main">workbox-broadcast-cache-update</a>
    - <a href="module-workbox-build.html#main">workbox-build</a>
    - <a href="module-workbox-cache-expiration.html#main">workbox-cache-expiration</a>
    - <a href="module-workbox-cacheable-response.html#main">workbox-cacheable-response</a>
    - <a href="module-workbox-google-analytics.html#main">workbox-google-analytics</a>
    - <a href="module-workbox-precaching.html#main">workbox-precaching</a>
    - <a href="module-workbox-routing.html#main">workbox-routing</a>
    - <a href="module-workbox-runtime-caching.html#main">workbox-runtime-caching</a>
    - <a href="module-workbox-sw.html#main">workbox-sw</a>
    - <a href="module-workbox-webpack-plugin.html#main">workbox-webpack-plugin</a>
    - <a href="workbox-range-requests%250A_%2520workbox-range-requests%250A%250AA%2520helper%2520library%2520that%2520instructs%2520a%2520service%2520worker%2520respond%2520to%2520HTTP%2520requests%250Athat%2520include%2520a%2520%255BRange_%255D(https___developer.mozilla.org_en-US_docs_Web_HTTP_Range_requests)%250Aheader%2520with%2520a%2520subset%2520of%2520a%2520full%2520response.%250A%250AIf%2520you%2520are%2520not%2520already%2520using%2520Workbox,%2520this%2520library%2520can%2520be%2520used%2520in%2520a%250Astandalone%2520form%2520via%250A%257B@link%2520handleRangeRequest_workbox.rangeRequests.handleRangeRequest%257D.%250A%250AIf%2520you%2520are%2520using%2520Workbox%2520for%2520routing%2520or%2520request%2520handling%2520already,%2520then%250A%257B@link%2520CacheRangeResponsePlugin%257D%2520will%2520offer%2520the%2520easiest%2520integration.%250A%250A__If%2520your%2520cached%2520resources%2520are%2520large,%2520use%2520caution%2520when%2520adding%2520this%2520library.%250ASome%2520browsers%2520need%2520to%2520read%2520the%2520entire%2520resource%2520into%2520memory%2520before%2520it%2520can%2520be%250Amodified%2520to%2520respond%2520to%2520the%2520request.__%250A%250AInspired%2520by%250A%250A-%2520https___github.com_jakearchibald_range-request-test_blob_master_static_sw.js%250A-%2520https___github.com_GoogleChrome_sample-media-pwa_blob_master_src_client_scripts_ranged-response.jsmodule_.html#main">workbox-range-requests
# workbox-range-requests

A helper library that instructs a service worker respond to HTTP requests
that include a [Range:](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)
header with a subset of a full response.

If you are not already using Workbox, this library can be used in a
standalone form via
{@link handleRangeRequest|workbox.rangeRequests.handleRangeRequest}.

If you are using Workbox for routing or request handling already, then
{@link CacheRangeResponsePlugin} will offer the easiest integration.

**If your cached resources are large, use caution when adding this library.
Some browsers need to read the entire resource into memory before it can be
modified to respond to the request.**

Inspired by

- https://github.com/jakearchibald/range-request-test/blob/master/static/sw.js
- https://github.com/GoogleChrome/sample-media-pwa/blob/master/src/client/scripts/ranged-response.js</a>
---





    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const swBuild = require('workbox-build');
const path = require('path');
const url = require('url');
/**
 * Use the instance of this in the plugins array of the webpack config.
 *
 * @example
 * const WorkboxBuildWebpackPlugin = require('workbox-webpack-plugin');
 * .
 * .
 * module.exports = {
 *   entry: {
 *     app: './step1/app.js'
 *   },
 *   output: {
 *     path: __dirname + '/step1/public/js',
 *     publicPath: '/public/js/',
 *     filename: '[name].js',
 *   },
 *   plugins: [
 *    new WorkboxBuildWebpackPlugin({
 *      globPatterns: ['**\/*.{html,js,css}'],
 *      globIgnores: ['admin.html'],
 *      swSrc: './src/sw.js',
 *      swDest: './build/sw.js',
 *     });
 *   ]
 * }
 *
 * @module workbox-webpack-plugin
 */
class WorkboxBuildWebpackPlugin {
  /**
   * Creates an instance of WorkboxBuildWebpackPlugin.
   *
   * @param {Object} [config] All the options as passed to `workbox-build`.
   */
  constructor(config) {
    this._config = config || {};
  }

  /**
   * @private
   * @param {Object} compilation The [compilation](https://github.com/webpack/docs/wiki/how-to-write-a-plugin#accessing-the-compilation),
   * passed from Webpack to this plugin.
   * @return {Object} The configuration for a given compilation.
   */
  getConfig(compilation) {
    let config = this._config;

    // If no root directory is given, fallback to
    // output path directory of webpack
    if (!config.globDirectory) {
      config.globDirectory = compilation.options.output.path;
    }

    if (!config.swDest) {
      config.swDest = path.join(compilation.options.output.path, 'sw.js');
    }

    if (!config.globPatterns) {
      config.globPatterns = ['**/*.{html,js,css}'];
    }

    if (compilation.options.output.publicPath) {
      const {publicPath} = compilation.options.output;
      const compiledAssets = [];
      for (let key in compilation.assets) {
        if (Object.prototype.hasOwnProperty.call(compilation.assets, key)) {
          compiledAssets.push(url.resolve(publicPath, key));
        }
      }

      const publicPathTransform = (manifestEntries) =>
          manifestEntries.map((entry) => {
            if (compilation.assets[entry.url]) {
              entry.url = url.resolve(publicPath, entry.url);
            }
              return entry;
          });

      if (Array.isArray(config.manifestTransforms)) {
        config.manifestTransforms.unshift(publicPathTransform);
      } else {
        config.manifestTransforms = [publicPathTransform];
      }
    }

    return config;
  }

  /**
   * @private
   * @param {Object} [compiler] default compiler object passed from webpack
   */
  apply(compiler) {
    compiler.plugin('after-emit', (compilation, callback) => {
      const config = this.getConfig(compilation);
      if (config.swSrc) {
        swBuild.injectManifest(config)
          .then(() => callback())
          .catch((e) => callback(e));
      } else {
        swBuild.generateSW(config)
        .then(() => callback())
        .catch((e) => callback(e));
      }
    });
  }
}

module.exports = WorkboxBuildWebpackPlugin;
</code></pre>
        </article>
    </section>





---
layout: jsdoc
title: "Source: packages/workbox-build/src/lib/utils/filter-files.js"
jsdocNav: 
  - Modules:
    - <a href="module-workbox-background-sync.html#main">workbox-background-sync</a>
    - <a href="module-workbox-broadcast-cache-update.html#main">workbox-broadcast-cache-update</a>
    - <a href="module-workbox-build.html#main">workbox-build</a>
    - <a href="module-workbox-cache-expiration.html#main">workbox-cache-expiration</a>
    - <a href="module-workbox-cacheable-response.html#main">workbox-cacheable-response</a>
    - <a href="module-workbox-google-analytics.html#main">workbox-google-analytics</a>
    - <a href="module-workbox-precaching.html#main">workbox-precaching</a>
    - <a href="module-workbox-routing.html#main">workbox-routing</a>
    - <a href="module-workbox-runtime-caching.html#main">workbox-runtime-caching</a>
    - <a href="module-workbox-sw.html#main">workbox-sw</a>
    - <a href="module-workbox-webpack-plugin.html#main">workbox-webpack-plugin</a>
    - <a href="workbox-range-requests%250A_%2520workbox-range-requests%250A%250AA%2520helper%2520library%2520that%2520instructs%2520a%2520service%2520worker%2520respond%2520to%2520HTTP%2520requests%250Athat%2520include%2520a%2520%255BRange_%255D(https___developer.mozilla.org_en-US_docs_Web_HTTP_Range_requests)%250Aheader%2520with%2520a%2520subset%2520of%2520a%2520full%2520response.%250A%250AIf%2520you%2520are%2520not%2520already%2520using%2520Workbox,%2520this%2520library%2520can%2520be%2520used%2520in%2520a%250Astandalone%2520form%2520via%250A%257B@link%2520handleRangeRequest_workbox.rangeRequests.handleRangeRequest%257D.%250A%250AIf%2520you%2520are%2520using%2520Workbox%2520for%2520routing%2520or%2520request%2520handling%2520already,%2520then%250A%257B@link%2520CacheRangeResponsePlugin%257D%2520will%2520offer%2520the%2520easiest%2520integration.%250A%250A__If%2520your%2520cached%2520resources%2520are%2520large,%2520use%2520caution%2520when%2520adding%2520this%2520library.%250ASome%2520browsers%2520need%2520to%2520read%2520the%2520entire%2520resource%2520into%2520memory%2520before%2520it%2520can%2520be%250Amodified%2520to%2520respond%2520to%2520the%2520request.__%250A%250AInspired%2520by%250A%250A-%2520https___github.com_jakearchibald_range-request-test_blob_master_static_sw.js%250A-%2520https___github.com_GoogleChrome_sample-media-pwa_blob_master_src_client_scripts_ranged-response.jsmodule_.html#main">workbox-range-requests
# workbox-range-requests

A helper library that instructs a service worker respond to HTTP requests
that include a [Range:](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)
header with a subset of a full response.

If you are not already using Workbox, this library can be used in a
standalone form via
{@link handleRangeRequest|workbox.rangeRequests.handleRangeRequest}.

If you are using Workbox for routing or request handling already, then
{@link CacheRangeResponsePlugin} will offer the easiest integration.

**If your cached resources are large, use caution when adding this library.
Some browsers need to read the entire resource into memory before it can be
modified to respond to the request.**

Inspired by

- https://github.com/jakearchibald/range-request-test/blob/master/static/sw.js
- https://github.com/GoogleChrome/sample-media-pwa/blob/master/src/client/scripts/ranged-response.js</a>
---





    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const constants = require('../constants');
const errors = require('../errors');
const logHelper = require('../log-helper');
const modifyUrlPrefixTranform = require('./modify-url-prefix-transform');
const noRevisionForUrlsMatchingTransform =
  require('./no-revision-for-urls-matching-transform');
const path = require('path');

/**
 * A `ManifestTransform` function can be used to modify the modify the `url` or
 * `revision` properties of some or all of the
 * {@link module:workbox-build#ManifestEntry|ManifestEntries} in the manifest.
 *
 * Deleting the `revision` property of an entry will cause
 * the corresponding `url` to be precached without cache-busting parameters
 * applied, which is to say, it implies that the URL itself contains
 * proper versioning info. If the `revision` property is present, it must be
 * set to a string.
 *
 * @example &lt;caption>A transformation that prepended the origin of a CDN for any
 * URL starting with '/assets/' could be implemented as:&lt;/caption>
 *
 * const cdnTransform = (manifestEntries) => manifestEntries.map(entry => {
 *   const cdnOrigin = 'https://example.com';
 *   if (entry.url.startsWith('/assets/')) {
 *     entry.url = cdnOrigin + entry.url;
 *   }
 *   return entry;
 * });
 *
 * @example &lt;caption>A transformation that removes the revision field when the
 * URL contains an 8-character hash surrounded by '.', indicating that it
 * already contains revision information:&lt;/caption>
 *
 * const removeRevisionTransform = (manifestEntries) => {
 *   return manifestEntries.map(entry => {
 *     const hashRegExp = /\.\w{8}\./;
 *     if (entry.url.match(hashRegExp)) {
 *       delete entry.revision;
 *     }
 *     return entry;
 *   });
 * };
 *
 * @callback ManifestTransform
 * @param {Array&lt;ManifestEntry>} manifestEntries The full array of entries,
 * prior to the current transformation.
 * @return {Array&lt;ManifestEntry>} The array of entries with the transformation
 * applied.
 * @memberof module:workbox-build
 */

module.exports = (fileDetails, options) => {
  const maximumFileSize = options.maximumFileSizeToCacheInBytes ||
    constants.maximumFileSize;
  const filteredFileDetails = fileDetails.filter((fileDetails) => {
    // Remove oversized files.
    if (fileDetails.size > maximumFileSize) {
      logHelper.warn(`Skipping file '${fileDetails.file}' due to size. ` +
        `[Max size supported is ${maximumFileSize}, this file is ` +
        `${fileDetails.size}]`);
      return false;
    }

    return true;
  });

  // Take the array of fileDetail objects and convert it into an array of
  // {url, revision} objects, with path.sep replaced with /.
  const normalizedManifest = filteredFileDetails.map((fileDetails) => {
    return {
      url: fileDetails.file.replace(path.sep, '/'),
      revision: fileDetails.hash,
    };
  });

  let manifestTransforms = [];

  if (options.modifyUrlPrefix) {
    manifestTransforms.push(modifyUrlPrefixTranform(options.modifyUrlPrefix));
  }

  if (options.dontCacheBustUrlsMatching) {
    manifestTransforms.push(
      noRevisionForUrlsMatchingTransform(options.dontCacheBustUrlsMatching));
  }

  if (options.manifestTransforms) {
    if (Array.isArray(options.manifestTransforms)) {
      manifestTransforms = manifestTransforms.concat(
        options.manifestTransforms
      );
    } else {
      throw new Error(errors['bad-manifest-transforms']);
    }
  }

  // Apply the transformations sequentially, and return the result.
  return manifestTransforms.reduce(
    (previousManifest, transform) => transform(previousManifest),
    normalizedManifest);
};
</code></pre>
        </article>
    </section>





---
layout: jsdoc
title: "Source: packages/workbox-cli/src/index.js"
jsdocNav: 
  - Modules:
    - <a href="module-workbox-background-sync.html#main">workbox-background-sync</a>
    - <a href="module-workbox-broadcast-cache-update.html#main">workbox-broadcast-cache-update</a>
    - <a href="module-workbox-build.html#main">workbox-build</a>
    - <a href="module-workbox-cache-expiration.html#main">workbox-cache-expiration</a>
    - <a href="module-workbox-cacheable-response.html#main">workbox-cacheable-response</a>
    - <a href="module-workbox-google-analytics.html#main">workbox-google-analytics</a>
    - <a href="module-workbox-precaching.html#main">workbox-precaching</a>
    - <a href="module-workbox-routing.html#main">workbox-routing</a>
    - <a href="module-workbox-runtime-caching.html#main">workbox-runtime-caching</a>
    - <a href="module-workbox-sw.html#main">workbox-sw</a>
    - <a href="module-workbox-webpack-plugin.html#main">workbox-webpack-plugin</a>
    - <a href="workbox-range-requests%250A_%2520workbox-range-requests%250A%250AA%2520helper%2520library%2520that%2520instructs%2520a%2520service%2520worker%2520respond%2520to%2520HTTP%2520requests%250Athat%2520include%2520a%2520%255BRange_%255D(https___developer.mozilla.org_en-US_docs_Web_HTTP_Range_requests)%250Aheader%2520with%2520a%2520subset%2520of%2520a%2520full%2520response.%250A%250AIf%2520you%2520are%2520not%2520already%2520using%2520Workbox,%2520this%2520library%2520can%2520be%2520used%2520in%2520a%250Astandalone%2520form%2520via%250A%257B@link%2520handleRangeRequest_workbox.rangeRequests.handleRangeRequest%257D.%250A%250AIf%2520you%2520are%2520using%2520Workbox%2520for%2520routing%2520or%2520request%2520handling%2520already,%2520then%250A%257B@link%2520CacheRangeResponsePlugin%257D%2520will%2520offer%2520the%2520easiest%2520integration.%250A%250A__If%2520your%2520cached%2520resources%2520are%2520large,%2520use%2520caution%2520when%2520adding%2520this%2520library.%250ASome%2520browsers%2520need%2520to%2520read%2520the%2520entire%2520resource%2520into%2520memory%2520before%2520it%2520can%2520be%250Amodified%2520to%2520respond%2520to%2520the%2520request.__%250A%250AInspired%2520by%250A%250A-%2520https___github.com_jakearchibald_range-request-test_blob_master_static_sw.js%250A-%2520https___github.com_GoogleChrome_sample-media-pwa_blob_master_src_client_scripts_ranged-response.jsmodule_.html#main">workbox-range-requests
# workbox-range-requests

A helper library that instructs a service worker respond to HTTP requests
that include a [Range:](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)
header with a subset of a full response.

If you are not already using Workbox, this library can be used in a
standalone form via
{@link handleRangeRequest|workbox.rangeRequests.handleRangeRequest}.

If you are using Workbox for routing or request handling already, then
{@link CacheRangeResponsePlugin} will offer the easiest integration.

**If your cached resources are large, use caution when adding this library.
Some browsers need to read the entire resource into memory before it can be
modified to respond to the request.**

Inspired by

- https://github.com/jakearchibald/range-request-test/blob/master/static/sw.js
- https://github.com/GoogleChrome/sample-media-pwa/blob/master/src/client/scripts/ranged-response.js</a>
---





    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
**/

'use strict';

const path = require('path');
const updateNotifier = require('update-notifier');
const workboxBuild = require('workbox-build');

const cliLogHelper = require('./lib/log-helper');
const generateGlobPattern = require('./lib/utils/generate-glob-pattern');
const saveConfigFile = require('./lib/utils/save-config');
const getConfig = require('./lib/utils/get-config');
const errors = require('./lib/errors');

const askForRootOfWebApp = require('./lib/questions/ask-root-of-web-app');
const askForServiceWorkerSrc = require('./lib/questions/ask-sw-src');
const askForServiceWorkerDest = require('./lib/questions/ask-sw-dest');
const askSaveConfigFile = require('./lib/questions/ask-save-config');
const askForExtensionsToCache =
  require('./lib/questions/ask-extensions-to-cache');

/**
 * This class is a wrapper to make test easier. This is used by
 * ./bin/index.js to pass in the args when the CLI is used.
 */
class SWCli {
  /**
   * This is a helper method that allows the test framework to call argv with
   * arguments without worrying about running as an actual CLI.
   *
   * @private
   * @param {Object} meowOutput The value passed in via process.argv.
   * @return {Promise} Promise is returned so testing framework knows when
   * handling the request has finished.
   */
  argv(meowOutput) {
    updateNotifier({pkg: meowOutput.pkg}).notify();

    if (meowOutput.input.length > 0) {
      // We have a command
      return this.handleCommand(
        meowOutput.input[0],
        meowOutput.input.splice(1),
        meowOutput.flags
      )
      .then(() => {
        process.exit(0);
      })
      .catch(() => {
        process.exit(1);
      });
    } else {
      meowOutput.showHelp(1);
    }
  }

  /**
   * If a command is given in the command line args, this method will handle
   * the appropriate action.
   * @param {string} command The command name.
   * @param {object} args The arguments given to this command.
   * @param {object} flags The flags supplied with the command line.
   * @return {Promise} A promise for the provided task.
   */
  handleCommand(command, args, flags) {
    switch (command) {
      case 'generate:sw':
        return this._generateSW(flags);
      case 'inject:manifest':
        return this._injectManifest(flags);
      default:
        cliLogHelper.error(`Invalid command given '${command}'`);
        return Promise.reject();
    }
  }

  /**
   * This method will generate a working service worker with a file manifest.
   * @param {Object} flags The flags supplied as part of the CLI input.
   * @return {Promise} The promise returned here will be used to exit the
   * node process cleanly or not.
   */
  _generateSW(flags) {
    let config = {};
    let configFile = null;
    if (flags) {
      configFile = flags.configFile;
      // Remove configFile from flags (if it was present) so that it doesn't
      // trigger the 'config-supplied-missing-fields' error later on.
      delete flags.configFile;
    }

    return getConfig(configFile)
    .then((savedConfig) => {
      if (savedConfig) {
        config = savedConfig;
      }
      config = Object.assign(config, flags);
    })
    .then(() => {
      const requiredFields = [
        'globDirectory',
        'globPatterns',
        'swDest',
      ];

      let askQuestions = false;
      requiredFields.forEach((requiredField) => {
        if (!config[requiredField]) {
          askQuestions = true;
        }
      });

      if (askQuestions) {
        // If some configuration is defined but not all required fields
        // throw an error forcing the developer to either go through
        // the guided flow OR go through the config only flow.
        if (Object.keys(config).length > 0) {
          cliLogHelper.error(errors['config-supplied-missing-fields'] +
            requiredFields.join(', '));
          return Promise.reject();
        }

        return this._askGenerateQuestions(config, requiredFields);
      }

      return Promise.resolve(config);
    })
    .then((config) => {
      return workboxBuild.generateSW(config);
    });
  }

  /**
   * Ask questions required for input.
   * @param  {object} config The config options.
   * @param  {object} requiredFields The required fields to ask questions for.
   * @return {Promise&lt;object>} Promise resolves to the config object.
   */
  _askGenerateQuestions(config, requiredFields) {
    return Promise.resolve()
    .then(() => {
      if (!config.globDirectory &amp;&amp;
        requiredFields.indexOf('globDirectory') !== -1) {
        return askForRootOfWebApp()
        .then((rDirectory) => {
          // This will give a pretty relative path:
          // '' => './'
          // 'build' => './build/'
          config.globDirectory =
            path.join('.', path.relative(process.cwd(), rDirectory), path.sep);
        });
      }
    })
    .then(() => {
      if (!config.globPatterns &amp;&amp;
        requiredFields.indexOf('globPatterns') !== -1) {
        return askForExtensionsToCache(config.globDirectory)
        .then((extensionsToCache) => {
          config.globPatterns = [
            generateGlobPattern(extensionsToCache),
          ];
        });
      }
    })
    .then(() => {
      if (!config.swSrc &amp;&amp;
        requiredFields.indexOf('swSrc') !== -1) {
        return askForServiceWorkerSrc()
        .then((swSrc) => {
          config.swSrc = swSrc;
        });
      }
    })
    .then(() => {
      if (!config.swDest &amp;&amp;
        requiredFields.indexOf('swDest') !== -1) {
        return askForServiceWorkerDest()
        .then((swDest) => {
          config.swDest = swDest;
        });
      }
    })
    .then(() => {
      return askSaveConfigFile();
    })
    .then((saveConfig) => {
      if (saveConfig) {
        return saveConfigFile(config);
      }
    })
    .then(() => config);
  }

  /**
   * This function should ask questions or use config/flags to read in a sw
   * and inject the manifest into the destination service worker.
   * @param  {object} flags Flags from command line.
   * @return {Promise} Resolves on
   */
  _injectManifest(flags) {
    let config = {};
    let configFile = null;
    if (flags) {
      configFile = flags.configFile;
      // Remove configFile from flags (if it was present) so that it doesn't
      // trigger the 'config-supplied-missing-fields' error later on.
      delete flags.configFile;
    }

    return getConfig(configFile)
    .then((savedConfig) => {
      if (savedConfig) {
        config = savedConfig;
      }
      config = Object.assign(config, flags);
    })
    .then(() => {
      const requiredFields = [
        'swSrc',
        'swDest',
        'globDirectory',
        'globPatterns',
      ];

      let askQuestions = false;
      requiredFields.forEach((requiredField) => {
        if (!config[requiredField]) {
          askQuestions = true;
        }
      });

      if (askQuestions) {
        // If some configuration is defined but not all required fields
        // throw an error forcing the developer to either go through
        // the guided flow OR go through the config only flow.
        if (Object.keys(config).length > 0) {
          cliLogHelper.error(errors['config-supplied-missing-fields'] +
            requiredFields.join(', '));
          return Promise.reject();
        }

        return this._askGenerateQuestions(config, requiredFields);
      }

      return Promise.resolve(config);
    })
    .then((config) => {
      return workboxBuild.injectManifest(config);
    });
  }
}

module.exports = SWCli;
</code></pre>
        </article>
    </section>





---
layout: jsdoc
title: "Source: packages/workbox-build/src/lib/get-file-manifest-entries.js"
jsdocNav: 
  - Modules:
    - <a href="module-workbox-background-sync.html#main">workbox-background-sync</a>
    - <a href="module-workbox-broadcast-cache-update.html#main">workbox-broadcast-cache-update</a>
    - <a href="module-workbox-build.html#main">workbox-build</a>
    - <a href="module-workbox-cache-expiration.html#main">workbox-cache-expiration</a>
    - <a href="module-workbox-cacheable-response.html#main">workbox-cacheable-response</a>
    - <a href="module-workbox-google-analytics.html#main">workbox-google-analytics</a>
    - <a href="module-workbox-precaching.html#main">workbox-precaching</a>
    - <a href="module-workbox-routing.html#main">workbox-routing</a>
    - <a href="module-workbox-runtime-caching.html#main">workbox-runtime-caching</a>
    - <a href="module-workbox-sw.html#main">workbox-sw</a>
    - <a href="module-workbox-webpack-plugin.html#main">workbox-webpack-plugin</a>
    - <a href="workbox-range-requests%250A_%2520workbox-range-requests%250A%250AA%2520helper%2520library%2520that%2520instructs%2520a%2520service%2520worker%2520respond%2520to%2520HTTP%2520requests%250Athat%2520include%2520a%2520%255BRange_%255D(https___developer.mozilla.org_en-US_docs_Web_HTTP_Range_requests)%250Aheader%2520with%2520a%2520subset%2520of%2520a%2520full%2520response.%250A%250AIf%2520you%2520are%2520not%2520already%2520using%2520Workbox,%2520this%2520library%2520can%2520be%2520used%2520in%2520a%250Astandalone%2520form%2520via%250A%257B@link%2520handleRangeRequest_workbox.rangeRequests.handleRangeRequest%257D.%250A%250AIf%2520you%2520are%2520using%2520Workbox%2520for%2520routing%2520or%2520request%2520handling%2520already,%2520then%250A%257B@link%2520CacheRangeResponsePlugin%257D%2520will%2520offer%2520the%2520easiest%2520integration.%250A%250A__If%2520your%2520cached%2520resources%2520are%2520large,%2520use%2520caution%2520when%2520adding%2520this%2520library.%250ASome%2520browsers%2520need%2520to%2520read%2520the%2520entire%2520resource%2520into%2520memory%2520before%2520it%2520can%2520be%250Amodified%2520to%2520respond%2520to%2520the%2520request.__%250A%250AInspired%2520by%250A%250A-%2520https___github.com_jakearchibald_range-request-test_blob_master_static_sw.js%250A-%2520https___github.com_GoogleChrome_sample-media-pwa_blob_master_src_client_scripts_ranged-response.jsmodule_.html#main">workbox-range-requests
# workbox-range-requests

A helper library that instructs a service worker respond to HTTP requests
that include a [Range:](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)
header with a subset of a full response.

If you are not already using Workbox, this library can be used in a
standalone form via
{@link handleRangeRequest|workbox.rangeRequests.handleRangeRequest}.

If you are using Workbox for routing or request handling already, then
{@link CacheRangeResponsePlugin} will offer the easiest integration.

**If your cached resources are large, use caution when adding this library.
Some browsers need to read the entire resource into memory before it can be
modified to respond to the request.**

Inspired by

- https://github.com/jakearchibald/range-request-test/blob/master/static/sw.js
- https://github.com/GoogleChrome/sample-media-pwa/blob/master/src/client/scripts/ranged-response.js</a>
---





    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const errors = require('./errors');
const filterFiles = require('./utils/filter-files');
const getCompositeDetails = require('./utils/get-composite-details');
const getFileDetails = require('./utils/get-file-details');
const getStringDetails = require('./utils/get-string-details');
const constants = require('./constants');

/**
 * @typedef {Object} ManifestEntry
 * @property {String} url The URL to the asset in the manifest.
 * @property {String} revision The revision details for the file. This is a
 * hash generated by node based on the file contents.
 * @memberof module:workbox-build
 */

/**
 * To get a list of files and revision details that can be used to ultimately
 * precache assets in a service worker.
 *
 * @param {module:workbox-build.Configuration} input
 * @return {Promise&lt;Array&lt;ManifestEntry>>}
 * An array of {@link module:workbox-build#ManifestEntry|ManifestEntries}
 * which will include a url and revision parameter.
 * @memberof module:workbox-build
 */
const getFileManifestEntries = (input) => {
  if (!input || typeof input !== 'object' || Array.isArray(input)) {
    return Promise.reject(
      new Error(errors['invalid-get-manifest-entries-input']));
  }

  // staticFileGlobs is to ease workbox to sw-precache migration.
  if (input.globPatterns &amp;&amp; input.staticFileGlobs) {
    return Promise.reject(
      new Error(errors['both-glob-patterns-static-file-globs']));
  }

  let globPatterns = input.globPatterns || input.staticFileGlobs;
  if (typeof input.globPatterns === 'undefined' &amp;&amp;
    typeof input.staticFileGlobs === 'undefined') {
    globPatterns = constants.defaultGlobPatterns;
  }

  const globIgnores = input.globIgnores || constants.defaultGlobIgnores;
  const globDirectory = input.globDirectory;

  // dynamicUrlToDependencies is to ease workbox to sw-precache migration.
  if (input.templatedUrls &amp;&amp; input.dynamicUrlToDependencies) {
    return Promise.reject(
      new Error(errors['both-templated-urls-dynamic-urls']));
  }
  const templatedUrls = input.templatedUrls || input.dynamicUrlToDependencies;

  if (typeof globDirectory !== 'string' || globDirectory.length === 0) {
    return Promise.reject(
      new Error(errors['invalid-glob-directory']));
  }

  if (!globPatterns || !Array.isArray(globPatterns)) {
    return Promise.reject(
      new Error(errors['invalid-static-file-globs']));
  }

  if (!globIgnores || !Array.isArray(globIgnores)) {
    return Promise.reject(
      new Error(errors['invalid-glob-ignores']));
  }

  // templatedUrls is optional.
  if (templatedUrls &amp;&amp; (
      typeof templatedUrls !== 'object' || Array.isArray(templatedUrls))) {
      return Promise.reject(new Error(errors['invalid-templated-urls']));
  }

  let validIgnores = true;
  globIgnores.forEach((pattern) => {
    if (typeof pattern !== 'string') {
      validIgnores = false;
    }
  });
  if (!validIgnores) {
    return Promise.reject(
      new Error(errors['invalid-glob-ignores']));
  }

  const fileSet = new Set();

  const fileDetails = globPatterns.reduce((accumulated, globPattern) => {
    const globbedFileDetails = getFileDetails(
      globDirectory, globPattern, globIgnores);
    globbedFileDetails.forEach((fileDetails) => {
      if (fileSet.has(fileDetails.file)) {
        return;
      }

      fileSet.add(fileDetails.file);
      accumulated.push(fileDetails);
    });
    return accumulated;
  }, []);

  // templatedUrls is optional.
  if (templatedUrls) {
    for (let url of Object.keys(templatedUrls)) {
      if (fileSet.has(url)) {
        return Promise.reject(
          new Error(errors['templated-url-matches-glob']));
      }

      const dependencies = templatedUrls[url];
      if (Array.isArray(dependencies)) {
        try {
          const dependencyDetails = dependencies.reduce((previous, pattern) => {
            try {
              const globbedFileDetails = getFileDetails(
                globDirectory, pattern, globIgnores);
              return previous.concat(globbedFileDetails);
            } catch (err) {
              const debugObj = {};
              debugObj[url] = dependencies;
              throw new Error(`${errors['bad-template-urls-asset']} ` +
                  `'${pattern}' in templateUrl '${JSON.stringify(debugObj)}' ` +
                  `could not be found.`);
            }
          }, []);
          fileDetails.push(getCompositeDetails(url, dependencyDetails));
        } catch (err) {
          return Promise.reject(err);
        }
      } else if (typeof dependencies === 'string') {
        fileDetails.push(getStringDetails(url, dependencies));
      } else {
        return Promise.reject(
          new Error(errors['invalid-templated-urls']));
      }
    }
  }

  return Promise.resolve(filterFiles(fileDetails, input));
};

module.exports = getFileManifestEntries;
</code></pre>
        </article>
    </section>





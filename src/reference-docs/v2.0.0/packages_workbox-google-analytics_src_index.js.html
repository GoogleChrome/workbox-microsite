---
layout: jsdoc
title: "Source: packages/workbox-google-analytics/src/index.js"
jsdocNav: 
  - Modules:
    - <a href="module-workbox-background-sync.html#main">workbox-background-sync</a>
    - <a href="module-workbox-broadcast-cache-update.html#main">workbox-broadcast-cache-update</a>
    - <a href="module-workbox-build.html#main">workbox-build</a>
    - <a href="module-workbox-cache-expiration.html#main">workbox-cache-expiration</a>
    - <a href="module-workbox-cacheable-response.html#main">workbox-cacheable-response</a>
    - <a href="module-workbox-google-analytics.html#main">workbox-google-analytics</a>
    - <a href="module-workbox-precaching.html#main">workbox-precaching</a>
    - <a href="module-workbox-routing.html#main">workbox-routing</a>
    - <a href="module-workbox-runtime-caching.html#main">workbox-runtime-caching</a>
    - <a href="module-workbox-sw.html#main">workbox-sw</a>
    - <a href="module-workbox-webpack-plugin.html#main">workbox-webpack-plugin</a>
    - <a href="workbox-range-requests%250A_%2520workbox-range-requests%250A%250AA%2520helper%2520library%2520that%2520instructs%2520a%2520service%2520worker%2520respond%2520to%2520HTTP%2520requests%250Athat%2520include%2520a%2520%255BRange_%255D(https___developer.mozilla.org_en-US_docs_Web_HTTP_Range_requests)%250Aheader%2520with%2520a%2520subset%2520of%2520a%2520full%2520response.%250A%250AIf%2520you%2520are%2520not%2520already%2520using%2520Workbox,%2520this%2520library%2520can%2520be%2520used%2520in%2520a%250Astandalone%2520form%2520via%250A%257B@link%2520handleRangeRequest_workbox.rangeRequests.handleRangeRequest%257D.%250A%250AIf%2520you%2520are%2520using%2520Workbox%2520for%2520routing%2520or%2520request%2520handling%2520already,%2520then%250A%257B@link%2520CacheRangeResponsePlugin%257D%2520will%2520offer%2520the%2520easiest%2520integration.%250A%250A__If%2520your%2520cached%2520resources%2520are%2520large,%2520use%2520caution%2520when%2520adding%2520this%2520library.%250ASome%2520browsers%2520need%2520to%2520read%2520the%2520entire%2520resource%2520into%2520memory%2520before%2520it%2520can%2520be%250Amodified%2520to%2520respond%2520to%2520the%2520request.__%250A%250AInspired%2520by%250A%250A-%2520https___github.com_jakearchibald_range-request-test_blob_master_static_sw.js%250A-%2520https___github.com_GoogleChrome_sample-media-pwa_blob_master_src_client_scripts_ranged-response.jsmodule_.html#main">workbox-range-requests
# workbox-range-requests

A helper library that instructs a service worker respond to HTTP requests
that include a [Range:](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)
header with a subset of a full response.

If you are not already using Workbox, this library can be used in a
standalone form via
{@link handleRangeRequest|workbox.rangeRequests.handleRangeRequest}.

If you are using Workbox for routing or request handling already, then
{@link CacheRangeResponsePlugin} will offer the easiest integration.

**If your cached resources are large, use caution when adding this library.
Some browsers need to read the entire resource into memory before it can be
modified to respond to the request.**

Inspired by

- https://github.com/jakearchibald/range-request-test/blob/master/static/sw.js
- https://github.com/GoogleChrome/sample-media-pwa/blob/master/src/client/scripts/ranged-response.js</a>
---





    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/* eslint-env worker, serviceworker */

import constants from './lib/constants.js';
import enqueueRequest from './lib/enqueue-request.js';
import logHelper from '../../../lib/log-helper.js';
import replayQueuedRequests from './lib/replay-queued-requests.js';

/**
 * In order to use the library, call
 * `workbox.googleAnalytics.initialize()`.
 * It will take care of setting up service worker `fetch` handlers to ensure
 * that the Google Analytics JavaScript is available offline, and that any
 * Google Analytics requests made while offline are saved (using `IndexedDB`)
 * and retried the next time the service worker starts up.
 *
 * @example
 * // This code should live inside your service worker JavaScript, ideally
 * // before any other 'fetch' event handlers are defined:
 *
 * // First, import the library into the service worker global scope:
 * importScripts('path/to/offline-google-analytics-import.js');
 *
 * // Then, call workbox.googleAnalytics.initialize():
 * workbox.googleAnalytics.initialize();
 *
 * // At this point, implement any other service worker caching strategies
 * // appropriate for your web app.
 *
 * @example
 * // If you need to specify parameters to be sent with each hit, you can use
 * // the `parameterOverrides` configuration option. This is useful in cases
 * // where you want to set a custom dimension on all hits sent by the service
 * // worker to differentiate them in your reports later.
 * workbox.googleAnalytics.initialize({
 *   parameterOverrides: {
 *     cd1: 'replay'
 *   }
 * });
 *
 * @example
 * // In situations where you need to programmatically modify a hit's
 * // parameters you can use the `hitFilter` option. One example of when this
 * // might be useful is if you wanted to track the amount of time that elapsed
 * // between when the hit was attempted and when it was successfully replayed.
 * workbox.googleAnalytics.initialize({
 *   hitFilter: searchParams =>
 *     // Sets the `qt` param as a custom metric.
 *     const qt = searchParams.get('qt');
 *     searchParams.set('cm1', qt);
 *   }
 * });
 *
 * @module workbox-google-analytics
 */

/**
 * @alias workbox.googleAnalytics.initialize
 * @param {Object=}   config
 * @param {Object=}   config.parameterOverrides
 *                    [Measurement Protocol parameters](https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters),
 *                    expressed as key/value pairs, to be added to replayed
 *                    Google Analytics requests. This can be used to, e.g., set
 *                    a custom dimension indicating that the request was
 *                    replayed.
 * @param {Function=} config.hitFilter
 *                    A function that allows you to modify the hit parameters
 *                    prior to replaying the hit. The function is invoked with
 *                    the original hit's URLSearchParams object as its only
 *                    argument. To abort the hit and prevent it from being
 *                    replayed, throw an error.
 * @memberof module:workbox-google-analytics
 */
const initialize = (config) => {
  config = config || {};

  // Stores whether or not the previous /collect request failed.
  let previousHitFailed = false;

  self.addEventListener('fetch', (event) => {
    const url = new URL(event.request.url);
    const request = event.request;

    if (url.hostname === constants.URL.HOST) {
      if (url.pathname === constants.URL.COLLECT_PATH) {
        // If this is a /collect request, then use a network-first strategy,
        // falling back to queueing the request in IndexedDB.

        // Make a clone of the request before we use it, in case we need
        // to read the request body later on.
        const clonedRequest = request.clone();

        event.respondWith(
          fetch(request).then((response) => {
            if (previousHitFailed) {
              replayQueuedRequests(config);
            }
            previousHitFailed = false;
            return response;
          }, (error) => {
            logHelper.log('Enqueuing failed request...');
            previousHitFailed = true;
            return enqueueRequest(clonedRequest).then(() => Response.error());
          })
        );
      } else if (url.pathname === constants.URL.ANALYTICS_JS_PATH) {
        // If this is a request for the Google Analytics JavaScript library,
        // use the network first, falling back to the previously cached copy.
        event.respondWith(
          caches.open(constants.CACHE_NAME).then((cache) => {
            return fetch(request).then((response) => {
              return cache.put(request, response.clone()).then(() => response);
            }).catch((error) => {
              logHelper.error(error);
              return cache.match(request);
            });
          })
        );
      }
    }
  });

  replayQueuedRequests(config);
};

export default {initialize};
</code></pre>
        </article>
    </section>





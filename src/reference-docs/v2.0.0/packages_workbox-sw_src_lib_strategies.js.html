---
layout: jsdoc
title: "Source: packages/workbox-sw/src/lib/strategies.js"
jsdocNav: 
  - Modules:
    - <a href="module-workbox-background-sync.html#main">workbox-background-sync</a>
    - <a href="module-workbox-broadcast-cache-update.html#main">workbox-broadcast-cache-update</a>
    - <a href="module-workbox-build.html#main">workbox-build</a>
    - <a href="module-workbox-cache-expiration.html#main">workbox-cache-expiration</a>
    - <a href="module-workbox-cacheable-response.html#main">workbox-cacheable-response</a>
    - <a href="module-workbox-google-analytics.html#main">workbox-google-analytics</a>
    - <a href="module-workbox-precaching.html#main">workbox-precaching</a>
    - <a href="module-workbox-routing.html#main">workbox-routing</a>
    - <a href="module-workbox-runtime-caching.html#main">workbox-runtime-caching</a>
    - <a href="module-workbox-sw.html#main">workbox-sw</a>
    - <a href="module-workbox-webpack-plugin.html#main">workbox-webpack-plugin</a>
    - <a href="workbox-range-requests%250A_%2520workbox-range-requests%250A%250AA%2520helper%2520library%2520that%2520instructs%2520a%2520service%2520worker%2520respond%2520to%2520HTTP%2520requests%250Athat%2520include%2520a%2520%255BRange_%255D(https___developer.mozilla.org_en-US_docs_Web_HTTP_Range_requests)%250Aheader%2520with%2520a%2520subset%2520of%2520a%2520full%2520response.%250A%250AIf%2520you%2520are%2520not%2520already%2520using%2520Workbox,%2520this%2520library%2520can%2520be%2520used%2520in%2520a%250Astandalone%2520form%2520via%250A%257B@link%2520handleRangeRequest_workbox.rangeRequests.handleRangeRequest%257D.%250A%250AIf%2520you%2520are%2520using%2520Workbox%2520for%2520routing%2520or%2520request%2520handling%2520already,%2520then%250A%257B@link%2520CacheRangeResponsePlugin%257D%2520will%2520offer%2520the%2520easiest%2520integration.%250A%250A__If%2520your%2520cached%2520resources%2520are%2520large,%2520use%2520caution%2520when%2520adding%2520this%2520library.%250ASome%2520browsers%2520need%2520to%2520read%2520the%2520entire%2520resource%2520into%2520memory%2520before%2520it%2520can%2520be%250Amodified%2520to%2520respond%2520to%2520the%2520request.__%250A%250AInspired%2520by%250A%250A-%2520https___github.com_jakearchibald_range-request-test_blob_master_static_sw.js%250A-%2520https___github.com_GoogleChrome_sample-media-pwa_blob_master_src_client_scripts_ranged-response.jsmodule_.html#main">workbox-range-requests
# workbox-range-requests

A helper library that instructs a service worker respond to HTTP requests
that include a [Range:](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)
header with a subset of a full response.

If you are not already using Workbox, this library can be used in a
standalone form via
{@link handleRangeRequest|workbox.rangeRequests.handleRangeRequest}.

If you are using Workbox for routing or request handling already, then
{@link CacheRangeResponsePlugin} will offer the easiest integration.

**If your cached resources are large, use caution when adding this library.
Some browsers need to read the entire resource into memory before it can be
modified to respond to the request.**

Inspired by

- https://github.com/jakearchibald/range-request-test/blob/master/static/sw.js
- https://github.com/GoogleChrome/sample-media-pwa/blob/master/src/client/scripts/ranged-response.js</a>
---





    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
  CacheFirst, CacheOnly, NetworkFirst,
  NetworkOnly, StaleWhileRevalidate,
} from '../../../workbox-runtime-caching/src/index.js';
import {CacheExpirationPlugin} from
  '../../../workbox-cache-expiration/src/index.js';
import {BroadcastCacheUpdatePlugin} from
  '../../../workbox-broadcast-cache-update/src/index.js';
import {CacheableResponsePlugin} from
  '../../../workbox-cacheable-response/src/index.js';
import {RequestWrapper} from '../../../workbox-runtime-caching/src/index.js';

/**
 * StrategyOptions is just a JavaScript object, but the structure
 * explains the options for runtime strategies used in workbox-sw.
 *
 * See the example of how this can be used with the `cacheFirst()` caching
 * strategy.
 *
 * @example
 * const workboxSW = new WorkboxSW();
 * const cacheFirstStrategy = workboxSW.strategies.cacheFirst({
 *   cacheName: 'example-cache',
 *   cacheExpiration: {
 *     maxEntries: 10,
 *     maxAgeSeconds: 7 * 24 * 60 * 60
 *   },
 *   broadcastCacheUpdate: {
 *     channelName: 'example-channel-name'
 *   },
 *   cacheableResponse: {
 *     statuses: [0, 200, 404],
 *     headers: {
 *       'Example-Header-1': 'Header-Value-1',
 *       'Example-Header-2': 'Header-Value-2'
 *     }
 *   }
 *   plugins: [
 *     // Additional Plugins
 *   ]
 * });
 *
 * @typedef {Object} StrategyOptions
 * @property {String} cacheName Name of cache to use
 * for caching (both lookup and updating).
 * @property {Object} cacheExpiration Defining this
 * object will add a cache expiration plugins to this strategy.
 * @property {Number} cacheExpiration.maxEntries
 * The maximum number of entries to store in a cache.
 * @property {Number} cacheExpiration.maxAgeSeconds
 * The maximum lifetime of a request to stay in the cache before it's removed.
 * @property {Object} broadcastCacheUpdate Defining
 * this object will add a broadcast cache update plugin.
 * @property {String} broadcastCacheUpdate.channelName
 * The name of the broadcast channel to dispatch messages on.
 * @property {Array&lt;plugins>} plugins For
 * any additional plugins you wish to add, simply include them in this
 * array.
 * @property {Object} cacheableResponse Specifies types of responses to cache
 * by status codes, headers, or both.
 * @property {Array&lt;Number>} cacheableResponse.statuses An array of status
 * codes to cache.
 * @property {Array&lt;Object>} cacheableResponse.headers An array of
 * header-value pairs for HTTP headers to cache. See the example, above.
 * @memberof module:workbox-sw.Strategies
 */

/**
 * This is a simple class used to namespace the supported caching strategies in
 * workbox-sw.
 *
 * You would never access this class directly but instead use with
 * `workboxSW.strategies.&lt;Strategy Name>`.
 *
 * @memberof module:workbox-sw
 */
class Strategies {
  /**
   * This constructor will configure shared options across each strategy.
   * @param {String} [input.cacheId] The cacheId to be applied to the run
   * time strategies cache names.
   */
  constructor({cacheId} = {}) {
    this._cacheId = cacheId;
  }

  /**
   * A [cache first](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network)
   * run-time caching strategy.
   *
   * @example
   * const = new WorkboxSW();
   * const cacheFirstStrategy = workboxSW.strategies.cacheFirst();
   *
   * workboxSW.router.registerRoute('/styles/*', cacheFirstStrategy);
   *
   * @param {module:workbox-sw.Strategies.StrategyOptions} [options] To
   * define any additional caching or broadcast plugins pass in option values.
   * @return {module:workbox-runtime-caching.CacheFirst} An instance of a
   * `CacheFirst` handler.
   */
  cacheFirst(options) {
    return this._getCachingMechanism(CacheFirst, options);
  }

  /**
   * A [cache only](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only)
   * run-time caching strategy.
   *
   * @example
   * const workboxSW = new WorkboxSW();
   * const cacheOnlyStrategy = workboxSW.strategies.cacheOnly();
   *
   * workboxSW.router.registerRoute('/styles/*', cacheOnlyStrategy);
   *
   * @param {module:workbox-sw.Strategies.StrategyOptions} [options] To
   * define any additional caching or broadcast plugins pass in option values.
   * @return {module:workbox-runtime-caching.CacheOnly} An instance of a
   * `CacheOnly` handler.
   */
  cacheOnly(options) {
    return this._getCachingMechanism(CacheOnly, options);
  }

  /**
   * A [network first](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache)
   * run-time caching strategy.
   *
   * @example
   * const workboxSW = new WorkboxSW();
   * const networkFirstStrategy = workboxSW.strategies.networkFirst();
   *
   * workboxSW.router.registerRoute('/blog/', networkFirstStrategy);
   *
   * @param {module:workbox-sw.Strategies.StrategyOptions} [options] To
   * define any additional caching or broadcast plugins pass in option values.
   * @return {module:workbox-runtime-caching.NetworkFirst} An instance of a
   * `NetworkFirst` handler.
   */
  networkFirst(options) {
    return this._getCachingMechanism(NetworkFirst, options);
  }

  /**
   * A [network only](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only)
   * run-time caching strategy.
   *
   * @example
   * const workboxSW = new WorkboxSW();
   * const networkOnlyStrategy = workboxSW.strategies.networkOnly();
   *
   * workboxSW.router.registerRoute('/admin/', networkOnlyStrategy);
   *
   * @param {module:workbox-sw.Strategies.StrategyOptions} [options] To
   * define any additional caching or broadcast plugins pass in option values.
   * @return {module:workbox-runtime-caching.NetworkOnly} An instance of a
   * `NetworkOnly` handler.
   */
  networkOnly(options) {
    return this._getCachingMechanism(NetworkOnly, options);
  }

  /**
   * A [stale while revalidate](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate)
   * run-time caching strategy.
   *
   * @example
   * const workboxSW = new WorkboxSW();
   * const staleWhileRevalidateStrategy =
   *  workboxSW.strategies.staleWhileRevalidate();
   *
   * workboxSW.router.registerRoute('/styles/*', staleWhileRevalidateStrategy);
   *
   * @param {module:workbox-sw.Strategies.StrategyOptions} [options] To
   * define any additional caching or broadcast plugins pass in option values.
   * @return {module:workbox-runtime-caching.StaleWhileRevalidate}
   *  An instance of a `StaleWhileRevalidate` handler.
   */
  staleWhileRevalidate(options) {
    return this._getCachingMechanism(StaleWhileRevalidate, options);
  }

  /**
   * This method will add plugins based on options passed in by the
   * developer.
   *
   * @private
   * @param {Class} HandlerClass The class to be configured and instantiated.
   * @param {Object} [options] Options to configure the handler.
   * @param {boolean} [options.excludeCacheId] If true, we assume that
   * options.cacheName already includes the cacheId, and it does not need to
   * be specified twice.
   * @return {Handler} A handler instance configured with the appropriate
   * behaviours
   */
  _getCachingMechanism(HandlerClass, options = {}) {
    const pluginParamsToClass = {
      'cacheExpiration': CacheExpirationPlugin,
      'broadcastCacheUpdate': BroadcastCacheUpdatePlugin,
      'cacheableResponse': CacheableResponsePlugin,
    };

    const wrapperOptions = {
      plugins: [],
    };

    if (!options.excludeCacheId) {
      wrapperOptions.cacheId = this._cacheId;
    }

    if (options['cacheName']) {
      wrapperOptions['cacheName'] = options['cacheName'];
    }

    // Iterate over known plugins and add them to Request Wrapper options.
    const pluginKeys = Object.keys(pluginParamsToClass);
    pluginKeys.forEach((pluginKey) => {
      if (options[pluginKey]) {
        const PluginClass = pluginParamsToClass[pluginKey];
        const pluginParams = options[pluginKey];

        wrapperOptions.plugins.push(new PluginClass(pluginParams));
      }
    });

    // Add custom plugins.
    if (options.plugins) {
      options.plugins.forEach((plugin) => {
        wrapperOptions.plugins.push(plugin);
      });
    }

    options.requestWrapper = new RequestWrapper(wrapperOptions);
    // Pass through the initial options to the underlying Handler constructor
    // to allow for Handler-specific customization.
    return new HandlerClass(options);
  }
}

export default Strategies;
</code></pre>
        </article>
    </section>




